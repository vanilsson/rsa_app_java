package RSA_app;

import java.math.BigInteger;
import java.util.Random;

/**
 * Stores keys that are either generated by class methods or supplied by the user. Also includes method to verify keys supplied by user.
 * Public key pair is made up of n (modulus) and e (exponent). Private key pair is made up of n (modulus) and d (exponent).
 */
public class KeyChain {
    private BigInteger n, e, d;
    EncryptorDecryptor encryptorDecryptor = new EncryptorDecryptor();

    /**
     * Checks whether encrypting and decrypting two arbitrary integers with supplied keys will return the same numbers.
     * @param n Modulus of public and private key.
     * @param e Public key exponent.
     * @param d Private key exponent.
     * @return True or false, depending on whether the keys are correct.
     */
    public boolean verifyKeys (BigInteger n, BigInteger e, BigInteger d) {

        BigInteger testMessageOne = BigInteger.valueOf(59);
        BigInteger testMessageOneEncrypted = encryptorDecryptor.encryptDecrypt(testMessageOne, e, n);
        BigInteger testMessageOneReturned = encryptorDecryptor.encryptDecrypt(testMessageOneEncrypted, d, n);
        boolean testOnePassed = (testMessageOne.equals(testMessageOneReturned));

        BigInteger testMessageTwo = BigInteger.valueOf(134);
        BigInteger testMessageTwoEncrypted = encryptorDecryptor.encryptDecrypt(testMessageTwo, e, n);
        BigInteger testMessageTwoReturned = encryptorDecryptor.encryptDecrypt(testMessageTwoEncrypted, d, n);
        boolean testTwoPassed = (testMessageTwo.equals(testMessageTwoReturned));

        boolean testThreePassed = (e.compareTo(n) >= 0);  // A very weak test, but still catches incorrect keys that pass the test above (i.e. (1000, 1, 1)).

        return testOnePassed && testTwoPassed && testThreePassed;  // True if passed all three tests.
    }

    public void setN(BigInteger n) {
        this.n = n;
    }

    public void setE(BigInteger e) {
        this.e = e;
    }

    public void setD(BigInteger d) {
        this.d = d;
    }

    public BigInteger getN() {
        return this.n;
    }

    public BigInteger getE() {
        return this.e;
    }

    public BigInteger getD() {
        return this.d;
    }


    /**
     * Generates the three BigIntegers n, e, and d, which are used to create the public keypair (e, n) and the private keypair (d, n).
     * Note: For secure encryption, 1024 bit keys should be generated, is not being generated here.
     */
    public void generateKeys() {
        int indexP, indexQ, minIndex, maxIndex, limitPrime, ratioMaxIndexMinIndex;
        Random random = new Random();
        ratioMaxIndexMinIndex = 10;  // Ratio between maxIndex and minIndex.
        limitPrime = 10000;
        int [] primes = generatePrimes(limitPrime);  // Returns array of primes up to limitPrime.
        maxIndex = primes.length - 1;  // Since index of last element of array is its length-1.
        minIndex = maxIndex / ratioMaxIndexMinIndex;
        indexP = random.nextInt(maxIndex - minIndex + 1) + minIndex;  // Generates random integer between minIndex and maxIndex (inclusively).
        indexQ = random.nextInt(maxIndex - minIndex + 1) + minIndex;
        while (indexP == indexQ) {  // To make sure p != q.
            indexQ = random.nextInt(maxIndex - minIndex + 1) + minIndex;
        }
        BigInteger p = BigInteger.valueOf(primes[indexP]);
        BigInteger q = BigInteger.valueOf(primes[indexQ]);
        n = p.multiply(q);
        BigInteger bigOne = BigInteger.valueOf(1);
        BigInteger phi = (p.subtract(bigOne)).multiply(q.subtract(bigOne));  // (p - 1) * (q - 1)
        e = BigInteger.valueOf(65537); // e having a short bit-length and small Hamming weight results in more efficient encryption  â€“ the most commonly chosen value for e is 216 + 1 = 65537. Can also be generated by choosing prime number<phi.
        if (phi.compareTo(e) <= 0) {  // equivalent to: if (phi <= e). Will only be true if source code is modified, but having it to make sure this requirement is not overlooked.
            System.out.println("ERROR: e is not smaller than (p-1(q-1). Please check e and limits for generating primes p and q.");
        } else {
        d = e.modInverse(phi);
        }
    }


    /**
     * Generates an array of prime numbers, from 2 up to limitPrime, using algorithm "Sieve of Eratosthenes".
     * Source of method: https://stackoverflow.com/questions/586284/finding-prime-numbers-with-the-sieve-of-eratosthenes-originally-is-there-a-bet
     * Authors: eleven81,Paul Tomblin, and Jon Skeet.
     * Date accessed: 2021-04-17
     * @param limitPrime Limit of how large primes to generate.
     * @return An array of prime numbers up to limitPrime.
     */
    private int [] generatePrimes(int limitPrime) {
        boolean[] isComposite = new boolean[limitPrime + 1];  // Adding a 1 since Array's index starts at zero, and the truth-values stored in the array are regarding the integer of same index.
        for (int i = 2; i * i <= limitPrime; i++) {  // Calculates all composites of "i".
            if (!isComposite [i]) {  // If "i" is not a composite (or no information is present about it).
                for (int j = i; i * j <= limitPrime; j++) {  // Calculates all composites of prime "i" up to "limitPrime".
                    isComposite [i*j] = true;  // Stores information of composites in array of booleans. If an integer is a composite, isComposite[integer] == true, else false.
                }
            }
        }
        int numPrimes = 0;  // Amount of primes.
        for (int i = 2; i <= limitPrime; i++) {
            if (!isComposite [i]) numPrimes++;  // Goes through whole array of booleans which indicates if integer "i" is a composite, incrementing "numPrimes" when false.
        }
        int [] primes = new int [numPrimes];  // Array for storing the primes.
        int index = 0;  // Since index of an array starts at zero.
        for (int i = 2; i <= limitPrime; i++) {
            if (!isComposite [i]) primes [index++] = i;  // If integer "i" is not a composite, add it to array of primes at position "index" and then increment the index.
        }
        return primes;
    }
}
